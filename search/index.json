[{"content":"Turning Debian into a network router involves configuring the system to forward IP packets between network interfaces and applying appropriate IP routing rules. This step-by-step guide walks you through the setup on a Debian 12 VM.\nPrerequisites:\nMake sure your VM has at least two network interfaces:\nOne for the external network (e.g., connected to the internet or another external network). One for the internal network (e.g., the LAN to be routed). You can check your network interfaces with:\n1 ip a Enable IP Forwarding Edit the sysctl configuration to enable IP forwarding permanently: 1 sudo sed -i \u0026#39;$ a net.ipv4.ip_forward=1\u0026#39; /etc/sysctl.conf Alternatively, open the sysctl configuration file /etc/sysctl.conf and locate or add the line net.ipv4.ip_forward = 1\nApply the changes immediately: 1 sudo sysctl -p To verify that IP forwarding is active:\n1 cat /proc/sys/net/ipv4/ip_forward It should return 1.\nConfigure Network Interfaces with systemd-networkd Verify that systemd-networkd is active Ensure systemd-networkd is running and enabled:\n1 2 sudo systemctl enable systemd-networkd sudo systemctl start systemd-networkd If you\u0026rsquo;re switching from ifupdown or another network manager, disable and remove it first:\n1 2 sudo systemctl disable networking sudo apt remove ifupdown Set Up the Network Configuration Define .network and .netdev files in /etc/systemd/network/. Each file should correspond to a network interface.\nExample:\nExternal interface (eth0): Create /etc/systemd/network/10-external.network: 1 2 3 4 5 [Match] Name=eth0 [Network] DHCP=yes Internal interface (eth1): Create /etc/systemd/network/20-internal.network: 1 2 3 4 5 [Match] Name=eth1 [Network] Address=192.168.1.1/24 Restart systemd-networkd Apply the configuration: 1 sudo systemctl restart systemd-networkd Verify Configuration Use networkctl to check the status of the interfaces: 1 networkctl status You should see both interfaces correctly configured.\nSet Up NAT (optional) To allow machines on the internal network to access external networks through the router, configure Network Address Translation (NAT) using nftables.\nMake sure nftables is running and enabled: 1 2 sudo systemctl enable nftables sudo systemctl start nftables Create a basic configuration file (e.g., /etc/nftables.conf): 1 2 3 4 5 6 table ip nat { chain postrouting { type nat hook postrouting priority 100; policy accept; oifname \u0026#34;eth0\u0026#34; masquerade } } Apply the rules: 1 sudo nft -f /etc/nftables.conf Configure Routing Rules (optional) Add any required static routes using ip route commands:\n1 sudo ip route add [destination_network] via [gateway_ip] dev [interface] Example:\n1 sudo ip route add 192.168.2.0/24 via 192.168.1.1 dev eth1 Install a DHCP Server (optional) To dynamically assign IPs to devices on the internal network, install and configure a DHCP server. In case of turning a Debian VM into a basic router, dnsmasq is a practical, efficient choice.\nInstall dnsmasq 1 2 sudo apt update sudo apt install dnsmasq Configure dnsmasq Edit the configuration file: 1 sudo nano /etc/dnsmasq.conf Add or modify the following lines for your setup:\nSpecify the internal interface to listen on: 1 interface=eth1 Define the DHCP range for the internal network: 1 dhcp-range=192.168.1.100,192.168.1.200,12h This assigns IP addresses from 192.168.1.100 to 192.168.1.200 with a lease time of 12 hours.\nSet the gateway (router) and DNS server (can be the router itself or another server): 1 2 dhcp-option=option:router,192.168.1.1 dhcp-option=option:dns-server,8.8.8.8 Restart dnsmasq Apply the configuration: 1 sudo systemctl restart dnsmasq Enable dnsmasq at Boot Ensure dnsmasq starts automatically: 1 sudo systemctl enable dnsmasq Verify dnsmasq is Running Check the status of the service: 1 sudo systemctl status dnsmasq Ensure itâ€™s listening on the correct interface:\n1 sudo netstat -ulnp | grep dnsmasq With these steps, Debian is now a fully functional network router, capable of managing traffic between your internal and external networks.\n","date":"2024-11-30T15:15:00Z","permalink":"https://killparty.github.io/p/setting-up-debian-as-a-gateway-router/","title":"Setting Up Debian as a Gateway Router"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 #!/bin/bash # # Bash Script Boilerplate # ======================== # A production-ready bash script template with: # - Error handling and strict mode # - Logging (optional, disabled by default) # - Lockfile mechanism (prevents multiple instances) # - Automatic cleanup on exit # - Log rotation # # Quick Start: # 1. Copy this file to your script name # 2. Add your logic in the main() function # 3. Uncomment and customize features as needed: # - Enable logging: change ENABLE_LOGGING to \u0026#34;true\u0026#34; below # - Add dependencies: uncomment and modify check_dependencies() # - Require root: uncomment the root check section # # Usage examples: # ./script.sh # Run with logging disabled # ENABLE_LOGGING=true ./script.sh # Enable logging via env var # LOG_DIR=/var/log ./script.sh # Enable logging to specific directory # # ============================================================================ # Configuration # ============================================================================ # Secure PATH export PATH=\u0026#39;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#39; # Strict mode (exits on error, undefined variables, pipe failures) set -euo pipefail IFS=$\u0026#39;\\n\\t\u0026#39; # Script metadata SCRIPT_NAME=\u0026#34;$(basename \u0026#34;$0\u0026#34;)\u0026#34; PID=$$ # Lockfile location (prevents multiple instances) LOCKFILE=\u0026#34;/tmp/${SCRIPT_NAME}.lock\u0026#34; # ============================================================================ # Logging Configuration # ============================================================================ # Enable logging: set to \u0026#34;true\u0026#34; to enable file logging, or keep \u0026#34;false\u0026#34; for console-only # You can also enable via environment: ENABLE_LOGGING=true ./script.sh ENABLE_LOGGING=\u0026#34;${ENABLE_LOGGING:-false}\u0026#34; # Log directory configuration # - If LOG_DIR env var is set, logging is automatically enabled # - Default: ~/.local/log (falls back to /tmp if HOME is not available) if [[ -n \u0026#34;${LOG_DIR:-}\u0026#34; ]]; then ENABLE_LOGGING=true elif [[ -n \u0026#34;${HOME:-}\u0026#34; ]] \u0026amp;\u0026amp; [[ -d \u0026#34;${HOME:-}\u0026#34; ]]; then LOG_DIR=\u0026#34;${HOME}/.local/log\u0026#34; else LOG_DIR=\u0026#34;/tmp\u0026#34; fi LOGFILE=\u0026#34;${LOG_DIR}/${SCRIPT_NAME}.log\u0026#34; MAX_LOG_SIZE=1048576 # Max log size: 1MB (1048576 bytes) LOG_BACKUP_COUNT=4 # Number of rotated log files to keep # ============================================================================ # Functions # ============================================================================ # Ensure log directory exists ensure_log_dir() { if [[ ! -d \u0026#34;$LOG_DIR\u0026#34; ]]; then mkdir -p \u0026#34;$LOG_DIR\u0026#34; 2\u0026gt;/dev/null || { echo \u0026#34;Error: Cannot create log directory: $LOG_DIR\u0026#34; \u0026gt;\u0026amp;2 return 1 } fi } # Logging function # Usage: log \u0026#34;INFO\u0026#34; \u0026#34;Your message here\u0026#34; # log \u0026#34;ERROR\u0026#34; \u0026#34;Something went wrong\u0026#34; # log \u0026#34;WARN\u0026#34; \u0026#34;Warning message\u0026#34; log() { local level=\u0026#34;$1\u0026#34; local message=\u0026#34;$2\u0026#34; local timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39; 2\u0026gt;/dev/null || echo \u0026#34;NO-DATE\u0026#34;) # If logging is disabled, output to console only if [[ \u0026#34;${ENABLE_LOGGING}\u0026#34; != \u0026#34;true\u0026#34; ]]; then if [[ \u0026#34;$level\u0026#34; == \u0026#34;ERROR\u0026#34; ]]; then echo \u0026#34;$timestamp [$level] : $message\u0026#34; \u0026gt;\u0026amp;2 else echo \u0026#34;$timestamp [$level] : $message\u0026#34; fi return 0 fi # Logging is enabled, write to file (and console) if ensure_log_dir 2\u0026gt;/dev/null; then echo \u0026#34;$timestamp [$level] : $message\u0026#34; | tee -a \u0026#34;$LOGFILE\u0026#34; 2\u0026gt;/dev/null || { echo \u0026#34;$timestamp [$level] : $message\u0026#34; \u0026gt;\u0026amp;2 } rotate_log_if_needed else # Fallback to stderr if log file is unavailable echo \u0026#34;$timestamp [$level] : $message\u0026#34; \u0026gt;\u0026amp;2 fi } # Log rotation function (runs automatically when log file exceeds MAX_LOG_SIZE) rotate_log_if_needed() { if [[ -f \u0026#34;$LOGFILE\u0026#34; ]]; then local log_size local timestamp=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) log_size=$(wc -c \u0026lt; \u0026#34;$LOGFILE\u0026#34;) if (( log_size \u0026gt; MAX_LOG_SIZE )); then echo \u0026#34;$timestamp [INFO] : Log file exceeded $MAX_LOG_SIZE bytes, rotating logs.\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOGFILE\u0026#34; for (( i=LOG_BACKUP_COUNT-1; i\u0026gt;0; i-- )); do if [[ -f \u0026#34;$LOGFILE.$i\u0026#34; ]]; then mv \u0026#34;$LOGFILE.$i\u0026#34; \u0026#34;$LOGFILE.$((i+1))\u0026#34; fi done mv \u0026#34;$LOGFILE\u0026#34; \u0026#34;$LOGFILE.1\u0026#34; : \u0026gt; \u0026#34;$LOGFILE\u0026#34; fi fi } # Error handler (called automatically on script errors) error_handler() { local exit_code=$? local line_no=$1 log \u0026#34;ERROR\u0026#34; \u0026#34;Script failed at line $line_no with exit code $exit_code.\u0026#34; 2\u0026gt;/dev/null || true exit \u0026#34;$exit_code\u0026#34; } # Lockfile mechanism to prevent multiple instances create_lockfile() { if [[ -f \u0026#34;$LOCKFILE\u0026#34; ]]; then local old_pid old_pid=$(cat \u0026#34;$LOCKFILE\u0026#34; 2\u0026gt;/dev/null || echo \u0026#34;\u0026#34;) if [[ -n \u0026#34;$old_pid\u0026#34; ]] \u0026amp;\u0026amp; kill -0 \u0026#34;$old_pid\u0026#34; 2\u0026gt;/dev/null; then log \u0026#34;ERROR\u0026#34; \u0026#34;Another instance is already running (PID: $old_pid). Lockfile: $LOCKFILE\u0026#34; exit 1 else # Stale lockfile detected, removing it rm -f \u0026#34;$LOCKFILE\u0026#34; log \u0026#34;INFO\u0026#34; \u0026#34;Removed stale lockfile at $LOCKFILE.\u0026#34; fi fi echo \u0026#34;$PID\u0026#34; \u0026gt; \u0026#34;$LOCKFILE\u0026#34; log \u0026#34;INFO\u0026#34; \u0026#34;Created lockfile at $LOCKFILE.\u0026#34; } # Clean up function (called automatically on exit) cleanup() { if [[ -z \u0026#34;${CLEANUP_DONE:-}\u0026#34; ]]; then export CLEANUP_DONE=1 if [[ -f \u0026#34;$LOCKFILE\u0026#34; ]]; then rm -f \u0026#34;$LOCKFILE\u0026#34; log \u0026#34;INFO\u0026#34; \u0026#34;Lockfile removed.\u0026#34; fi fi } # Check required commands (dependencies) # Uncomment and modify as needed: check_dependencies() { # Example: Check for required commands # local dependencies=(\u0026#34;curl\u0026#34; \u0026#34;jq\u0026#34; \u0026#34;git\u0026#34;) # for cmd in \u0026#34;${dependencies[@]}\u0026#34;; do # if ! command -v \u0026#34;$cmd\u0026#34; \u0026amp;\u0026gt; /dev/null; then # log \u0026#34;ERROR\u0026#34; \u0026#34;Required command \u0026#39;$cmd\u0026#39; not found in PATH.\u0026#34; # exit 1 # fi # done : } # Main script logic - ADD YOUR CODE HERE main() { log \u0026#34;INFO\u0026#34; \u0026#34;Starting $SCRIPT_NAME\u0026#34; # ======================================== # TODO: Add your script logic here # ======================================== # # Examples: # log \u0026#34;INFO\u0026#34; \u0026#34;Processing files...\u0026#34; # if some_condition; then # log \u0026#34;ERROR\u0026#34; \u0026#34;Something went wrong\u0026#34; # exit 1 # fi # log \u0026#34;INFO\u0026#34; \u0026#34;Done processing\u0026#34; # log \u0026#34;INFO\u0026#34; \u0026#34;Completed successfully.\u0026#34; } # ============================================================================ # Optional: Root Check # ============================================================================ # Uncomment the block below if your script requires root privileges # if [[ \u0026#34;$EUID\u0026#34; -ne 0 ]]; then # log \u0026#34;ERROR\u0026#34; \u0026#34;This script must be run as root.\u0026#34; # exit 1 # fi # ============================================================================ # Signal handlers and execution # ============================================================================ # Set up error handler and cleanup on exit trap \u0026#39;error_handler $LINENO\u0026#39; ERR trap \u0026#39;cleanup; exit\u0026#39; INT TERM EXIT # Initialize and run if [[ \u0026#34;${ENABLE_LOGGING}\u0026#34; == \u0026#34;true\u0026#34; ]]; then ensure_log_dir fi create_lockfile check_dependencies main cleanup ","date":"2024-10-23T17:02:00Z","permalink":"https://killparty.github.io/p/bash-boilerplate/","title":"Bash Boilerplate"}]