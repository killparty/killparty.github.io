[{"content":"Turning Debian into a network router involves configuring the system to forward IP packets between network interfaces and applying appropriate IP routing rules. This step-by-step guide walks you through the setup on a Debian 12 VM.\nPrerequisites:\nMake sure your VM has at least two network interfaces:\nOne for the external network (e.g., connected to the internet or another external network). One for the internal network (e.g., the LAN to be routed). You can check your network interfaces with:\n1 ip a Enable IP Forwarding Edit the sysctl configuration to enable IP forwarding permanently: 1 sudo sed -i \u0026#39;$ a net.ipv4.ip_forward=1\u0026#39; /etc/sysctl.conf Alternatively, open the sysctl configuration file /etc/sysctl.conf and locate or add the line net.ipv4.ip_forward = 1\nApply the changes immediately: 1 sudo sysctl -p To verify that IP forwarding is active:\n1 cat /proc/sys/net/ipv4/ip_forward It should return 1.\nConfigure Network Interfaces with systemd-networkd Verify that systemd-networkd is active Ensure systemd-networkd is running and enabled:\n1 2 sudo systemctl enable systemd-networkd sudo systemctl start systemd-networkd If you\u0026rsquo;re switching from ifupdown or another network manager, disable and remove it first:\n1 2 sudo systemctl disable networking sudo apt remove ifupdown Set Up the Network Configuration Define .network and .netdev files in /etc/systemd/network/. Each file should correspond to a network interface.\nExample:\nExternal interface (eth0): Create /etc/systemd/network/10-external.network: 1 2 3 4 5 [Match] Name=eth0 [Network] DHCP=yes Internal interface (eth1): Create /etc/systemd/network/20-internal.network: 1 2 3 4 5 [Match] Name=eth1 [Network] Address=192.168.1.1/24 Restart systemd-networkd Apply the configuration: 1 sudo systemctl restart systemd-networkd Verify Configuration Use networkctl to check the status of the interfaces: 1 networkctl status You should see both interfaces correctly configured.\nSet Up NAT (optional) To allow machines on the internal network to access external networks through the router, configure Network Address Translation (NAT) using nftables.\nMake sure nftables is running and enabled: 1 2 sudo systemctl enable nftables sudo systemctl start nftables Create a basic configuration file (e.g., /etc/nftables.conf): 1 2 3 4 5 6 table ip nat { chain postrouting { type nat hook postrouting priority 100; policy accept; oifname \u0026#34;eth0\u0026#34; masquerade } } Apply the rules: 1 sudo nft -f /etc/nftables.conf Configure Routing Rules (optional) Add any required static routes using ip route commands:\n1 sudo ip route add [destination_network] via [gateway_ip] dev [interface] Example:\n1 sudo ip route add 192.168.2.0/24 via 192.168.1.1 dev eth1 Install a DHCP Server (optional) To dynamically assign IPs to devices on the internal network, install and configure a DHCP server. In case of turning a Debian VM into a basic router, dnsmasq is a practical, efficient choice.\nInstall dnsmasq 1 2 sudo apt update sudo apt install dnsmasq Configure dnsmasq Edit the configuration file: 1 sudo nano /etc/dnsmasq.conf Add or modify the following lines for your setup:\nSpecify the internal interface to listen on: 1 interface=eth1 Define the DHCP range for the internal network: 1 dhcp-range=192.168.1.100,192.168.1.200,12h This assigns IP addresses from 192.168.1.100 to 192.168.1.200 with a lease time of 12 hours.\nSet the gateway (router) and DNS server (can be the router itself or another server): 1 2 dhcp-option=option:router,192.168.1.1 dhcp-option=option:dns-server,8.8.8.8 Restart dnsmasq Apply the configuration: 1 sudo systemctl restart dnsmasq Enable dnsmasq at Boot Ensure dnsmasq starts automatically: 1 sudo systemctl enable dnsmasq Verify dnsmasq is Running Check the status of the service: 1 sudo systemctl status dnsmasq Ensure it’s listening on the correct interface:\n1 sudo netstat -ulnp | grep dnsmasq With these steps, Debian is now a fully functional network router, capable of managing traffic between your internal and external networks.\n","date":"2024-11-30T15:15:00Z","permalink":"https://killparty.github.io/p/setting-up-debian-as-a-gateway-router/","title":"Setting Up Debian as a Gateway Router"},{"content":"Writing reliable Bash scripts can be tricky, but having a solid starting point helps. Below is a Bash boilerplate that I often use to make scripts safer and easier to manage.\nIt includes strict error handling (set -euo pipefail) to catch mistakes early, log rotation to keep log files from getting too big, and a lockfile to prevent multiple script instances from running at the same time. There’s also a section for checking dependencies and handling cleanups.\nCustomization: Modify the main function to include the actual logic of your script. Add or remove dependencies as needed in the check_dependencies function. Adjust paths for the LOCKFILE and LOGFILE as per your requirements. Remove the root check in case it is not required. This template ensures your script adheres to good security and reliability standards, minimizing the risk of common pitfalls in bash scripting.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #!/bin/bash # Strict mode - makes the script safer and more reliable set -euo pipefail IFS=$\u0026#39;\\n\\t\u0026#39; # Variables LOCKFILE=\u0026#34;/tmp/$(basename \u0026#34;$0\u0026#34;).lock\u0026#34; LOGFILE=\u0026#34;/var/log/$(basename \u0026#34;$0\u0026#34;).log\u0026#34; PID=$$ SCRIPT_NAME=\u0026#34;$(basename \u0026#34;$0\u0026#34;)\u0026#34; START_TIME=$(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;) MAX_LOG_SIZE=1048576 # Max log size in bytes (1MB = 1048576 bytes) LOG_BACKUP_COUNT=5 # Number of rotated logs to keep # Logging function log() { local level=\u0026#34;$1\u0026#34; local message=\u0026#34;$2\u0026#34; echo \u0026#34;$START_TIME [$level] : $message\u0026#34; | tee -a \u0026#34;$LOGFILE\u0026#34; rotate_log_if_needed } # Log rotation function rotate_log_if_needed() { if [[ -f \u0026#34;$LOGFILE\u0026#34; ]]; then local log_size log_size=$(stat -c%s \u0026#34;$LOGFILE\u0026#34;) if (( log_size \u0026gt; MAX_LOG_SIZE )); then echo \u0026#34;$START_TIME [INFO] : Log file exceeded $MAX_LOG_SIZE bytes, rotating logs.\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOGFILE\u0026#34; for (( i=LOG_BACKUP_COUNT-1; i\u0026gt;0; i-- )); do if [[ -f \u0026#34;$LOGFILE.$i\u0026#34; ]]; then mv \u0026#34;$LOGFILE.$i\u0026#34; \u0026#34;$LOGFILE.$((i+1))\u0026#34; fi done mv \u0026#34;$LOGFILE\u0026#34; \u0026#34;$LOGFILE.1\u0026#34; : \u0026gt; \u0026#34;$LOGFILE\u0026#34; # Truncate the log file fi fi } # Clean up function cleanup() { if [[ -f \u0026#34;$LOCKFILE\u0026#34; ]]; then rm -f \u0026#34;$LOCKFILE\u0026#34; log \u0026#34;INFO\u0026#34; \u0026#34;Lock file removed\u0026#34; fi } # Lockfile mechanism to avoid multiple instances create_lockfile() { if [[ -f \u0026#34;$LOCKFILE\u0026#34; ]]; then log \u0026#34;ERROR\u0026#34; \u0026#34;Lockfile exists: $LOCKFILE. Another instance is running.\u0026#34; exit 1 fi echo \u0026#34;$PID\u0026#34; \u0026gt; \u0026#34;$LOCKFILE\u0026#34; log \u0026#34;INFO\u0026#34; \u0026#34;Created lockfile: $LOCKFILE\u0026#34; } # Trap signals to ensure cleanup trap \u0026#39;cleanup; exit\u0026#39; INT TERM EXIT # Root check (if needed) if [[ \u0026#34;$EUID\u0026#34; -ne 0 ]]; then log \u0026#34;ERROR\u0026#34; \u0026#34;This script must be run as root\u0026#34; exit 1 fi # Secure PATH (avoids executing malicious binaries in an altered PATH) export PATH=\u0026#39;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#39; # Function to check required commands (dependencies) check_dependencies() { local dependencies=(\u0026#34;command1\u0026#34; \u0026#34;command2\u0026#34;) # Replace with actual commands for cmd in \u0026#34;${dependencies[@]}\u0026#34;; do if ! command -v \u0026#34;$cmd\u0026#34; \u0026amp;\u0026gt; /dev/null; then log \u0026#34;ERROR\u0026#34; \u0026#34;Dependency \u0026#39;$cmd\u0026#39; is not installed or not in PATH.\u0026#34; exit 1 fi done } # Function to handle errors error_handler() { local exit_code=$? local line_no=$1 log \u0026#34;ERROR\u0026#34; \u0026#34;Error on line $line_no: Exit code $exit_code\u0026#34; exit \u0026#34;$exit_code\u0026#34; } trap \u0026#39;error_handler $LINENO\u0026#39; ERR # Main script logic main() { log \u0026#34;INFO\u0026#34; \u0026#34;Starting script: $SCRIPT_NAME\u0026#34; # Add your script logic here # ... log \u0026#34;INFO\u0026#34; \u0026#34;Script completed successfully\u0026#34; } # Run the main logic create_lockfile check_dependencies main cleanup Explanation and Best Practices: Strict Mode:\nset -euo pipefail: -e: Exit immediately if a command exits with a non-zero status. -u: Treat unset variables as an error. -o pipefail: Ensures that if any part of a pipe fails, the entire pipeline fails. IFS=$'\\n\\t': Ensures that word splitting is done only on newlines and tabs, preventing security issues with spaces. Lockfile Mechanism:\nThe script uses a lockfile (/tmp/${SCRIPT_NAME}.lock) to ensure only one instance runs at a time. If the script is already running (lockfile exists), it exits to avoid multiple instances. Logging:\nlog() function logs messages with a timestamp, log level (INFO, ERROR, etc.), and appends them to a log file (/var/log/${SCRIPT_NAME}.log). Log entries are echoed to both the terminal and log file. Signal Trapping and Cleanup:\ntrap 'cleanup; exit' INT TERM EXIT: This ensures the lockfile is removed if the script exits unexpectedly (e.g., via Ctrl+C or system signals). Cleanup function removes the lockfile, avoiding stale lockfiles. Root Check:\nIf the script requires root privileges, this check prevents it from running as a non-root user. Secure PATH:\nThe script explicitly sets the PATH to a known secure set of directories, avoiding potential execution of malicious commands from user-controlled locations. Dependency Checks:\nThe check_dependencies function ensures that all required commands (command1, command2, etc.) are available before the script proceeds. You can replace these with actual dependencies. Error Handling:\nThe error_handler function is triggered on any error (via the ERR trap), providing useful information about where the error occurred and what the exit code was. Feel free to use this template as a foundation for your own scripts and tweak it to fit your needs!\n","date":"2024-10-23T17:02:00Z","permalink":"https://killparty.github.io/p/bash-boilerplate/","title":"Bash Boilerplate"}]